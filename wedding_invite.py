# -*- coding: utf-8 -*-
"""wedding-invite.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10nN8IwdXOPcsqtpdDzhXBheEU_0M1inp
"""

# Installing the required libraries for Google Collab
!pip install requests -q

import requests
import time
from google.colab import files
from IPython.display import display, HTML
import os

# Play.ht API Credentials, will be stored seperately not here.
API_URL = "https://api.play.ht/api/v2/cloned-voices/instant"
API_KEY = "b71d318c51054a4da51508270d9f1e3a"
USER_ID = "LCAvjowUV6SO6dplwkW2NzJgC6j1"
VOICE_NAME = "invite"

# Cloudinary Credentials, will be stored seperately not here.
CLOUD_NAME = "ddxj5oej8"
CLOUD_API_KEY = "169243361242178"
CLOUD_API_SECRET = "gbRBrGMHxoaqeD6GKxANRuxOsPQ"
UPLOAD_PRESET = "hackathon_2024"

# D-ID API Credentials, will be stored seperately not here
D_ID_API_URL = "https://api.d-id.com/talks"
D_ID_AUTHORIZATION = "Basic YzJGeWRtRm5lV0Z3Y21GMFpXVnJRR2R0WVdsc0xtTnZiUTpJREV3cWF4bTdHTGhOcTJMVm5OLXE="

# Function to upload the audio file
def upload_audio():
    print("Please upload an audio file:")
    uploaded = files.upload()
    for filename in uploaded.keys():
        print(f"Uploaded audio file: {filename}")
    return uploaded

# Function to upload an image to Cloudinary (server required to host the image to be given as input to the D-ID api)
def upload_image_to_cloudinary(image_path):
    url = f"https://api.cloudinary.com/v1_1/{CLOUD_NAME}/image/upload"
    with open(image_path, "rb") as file:
        payload = {
            "upload_preset": UPLOAD_PRESET,
        }
        files_data = {
            "file": file,
        }
        auth = (CLOUD_API_KEY, CLOUD_API_SECRET)
        response = requests.post(url, auth=auth, data=payload, files=files_data)
        if response.status_code == 200:
            data = response.json()
            return data["secure_url"], data["format"]
        else:
            raise Exception(f"Error: {response.status_code}, {response.text}")

# Sending the file to Play.ht API to generate the voice ID
def get_voice_id_from_audio(audio_path):
    files = {'sample_file': (os.path.basename(audio_path), open(audio_path, 'rb'), 'audio/mpeg')}
    payload = {'voice_name': VOICE_NAME}
    headers = {
        "accept": "application/json",
        "AUTHORIZATION": API_KEY,
        "X-USER-ID": USER_ID
    }

    response = requests.post(API_URL, data=payload, files=files, headers=headers)

    if response.status_code == 201:
        result = response.json()
        voice_id = result.get("id")
        if voice_id:
            print(f"Voice ID: {voice_id}")
            return voice_id
        else:
            print("Error: No voice ID returned by the API")
            return None
    else:
        print(f"API request failed with status code {response.status_code}")
        return None

# Using the voice ID to generate Speech from Text
def generate_speech(voice_id, text_to_speak):
    url = "https://api.play.ht/api/v2/tts"
    payload = {
        "voice": voice_id,
        "output_format": "mp3",
        "voice_engine": "PlayHT2.0",
        "text": text_to_speak
    }
    headers = {
        "accept": "text/event-stream",
        "content-type": "application/json",
        "AUTHORIZATION": API_KEY,
        "X-USER-ID": USER_ID
    }

    response = requests.post(url, json=payload, headers=headers, stream=True)

    if response.status_code == 200:
        print(f"TTS request sent for text: '{text_to_speak}'. Waiting for completion...")

        for line in response.iter_lines():
            if line:
                decoded_line = line.decode('utf-8')
                if "data" in decoded_line:
                    data = decoded_line.split("data:")[1].strip()
                    try:
                        result = eval(data)
                        audio_url = result.get("url")
                        if audio_url:
                            print(f"Audio URL: {audio_url}")
                            return audio_url
                    except Exception as e:
                        print(f"Error parsing event data: {e}")
    else:
        print(f"Failed to generate speech for text '{text_to_speak}'. Status Code: {response.status_code}")
        return None

# Generating videos using D-ID API
def generate_video(image_url, audio_url):
    payload = {
        "source_url": image_url,
        "script": {
            "type": "audio",
            "input": "This will be replaced dynamically",
            "audio_url": audio_url,
            "reduce_noise": True
        },
        "config": {
            "fluent": "false",
            "pad_audio": "0.0"
        }
    }
    headers = {
        "accept": "application/json",
        "content-type": "application/json",
        "authorization": D_ID_AUTHORIZATION
    }

    response = requests.post(D_ID_API_URL, json=payload, headers=headers)
    if response.status_code == 201:
        result = response.json()
        video_id = result.get("id")
        print(f"Video ID: {video_id}")
        return video_id
    else:
        print(f"Failed to generate video. Status Code: {response.status_code}")
        return None

# Checking the video status and extracting the result URL from the response
def get_video_status(video_id):
    url = f"https://api.d-id.com/talks/{video_id}"
    headers = {
        "accept": "application/json",
        "authorization": D_ID_AUTHORIZATION
    }

    while True:
        response = requests.get(url, headers=headers)
        if response.status_code == 200:
            result = response.json()
            if result["status"] == "done":
                video_url = result.get("result_url")
                print(f"Video URL: {video_url}")
                return video_url
            elif result["status"] == "failed":
                print("Video generation failed.")
                return None
            else:
                print("Video still processing... Retrying in 5 seconds.")
                time.sleep(5)
        else:
            print(f"Failed to fetch video status. Status Code: {response.status_code}")
            return None

# Playing and downloading the video in Google Collab
def play_and_download_video(video_url):
    display(HTML(f'<video controls src="{video_url}" width="512"></video>'))
    display(HTML(f'<a href="{video_url}" download="generated_video.mp4">Download Video</a>'))


def main():
    # Uploading the audio file
    uploaded_audio = upload_audio()
    audio_filename = list(uploaded_audio.keys())[0]

    # Uploading the image file
    print("Please upload an image file:")
    uploaded_image = files.upload()
    image_filename = list(uploaded_image.keys())[0]

    try:
        # Uploading the image to Cloudinary (any server would work here)
        image_url, _ = upload_image_to_cloudinary(image_filename)
        print(f"Image successfully uploaded to Cloudinary! URL: {image_url}")
    except Exception as e:
        print(f"Image upload failed: {e}")
        return

    # Getting the voice ID from the uploaded audio file
    voice_id = get_voice_id_from_audio(audio_filename)

    if voice_id:
        # Getting the user input for names
        names_input = input("Enter a comma-separated list of names (e.g.,Aman,Suresh):")
        names = [name.strip() for name in names_input.split(',')]

        # Generating speech and video for each name
        for name in names:
            text_to_speak = f"Hey {name}, I am super excited to invite you to Sheena and my wedding on 25th November,  at Garden Galleria, Noida. It would mean a lot,  to have you with us,  on this special day! Your presence will make the day even more joyful!"
            audio_url = generate_speech(voice_id, text_to_speak)

            if audio_url:
                video_id = generate_video(image_url, audio_url)
                if video_id:
                    video_url = get_video_status(video_id)
                    if video_url:
                        play_and_download_video(video_url)

main()